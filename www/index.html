<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>3D æ‰‹åŠ¿äº¤äº’ç²’å­ç³»ç»Ÿ (ç§»åŠ¨ç‰ˆ)</title>
    <link rel="manifest" href="manifest.webmanifest">
    <style>
        /* ç§»åŠ¨ç«¯ä¼˜åŒ–ï¼šç¦æ­¢ç¼©æ”¾ã€é€‰ä¸­å’Œé»˜è®¤è§¦æ‘¸è¡Œä¸º */
        * { touch-action: none; user-select: none; -webkit-tap-highlight-color: transparent; }
        body { margin: 0; overflow: hidden; background-color: #050505; font-family: 'Segoe UI', sans-serif; }
        canvas { display: block; }
        
        /* Loading é®ç½© */
        #loader {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: #000; color: #00ffff; display: flex; flex-direction: column;
            justify-content: center; align-items: center; z-index: 999;
            transition: opacity 0.5s;
        }
        
        /* UI é¢æ¿ */
        #ui-panel {
            position: absolute; top: 20px; right: 20px;
            width: 260px;
            background: rgba(20, 20, 35, 0.8);
            backdrop-filter: blur(10px);
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            padding: 20px;
            color: white;
            z-index: 10;
            box-shadow: 0 4px 20px rgba(0,0,0,0.5);
            transition: transform 0.3s ease, opacity 0.3s ease;
        }

        #toolbar {
            position: absolute; bottom: 30px; right: 20px;
            top: auto; left: auto;
            display: flex; gap: 15px; z-index: 100;
            flex-direction: column; align-items: flex-end;
        }

        .tool-btn {
            background: rgba(20, 20, 35, 0.85);
            border: 1px solid rgba(0, 229, 255, 0.3);
            color: #fff; padding: 12px 16px; border-radius: 30px;
            font-size: 14px; letter-spacing: 0.5px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.4);
            backdrop-filter: blur(4px);
            transition: all 0.2s;
        }

        .tool-btn:active { transform: scale(0.95); background: rgba(0, 229, 255, 0.2); }

        .panel-hidden #ui-panel {
            transform: translateX(120%);
            opacity: 0;
            pointer-events: none;
        }

        h2 { margin: 0 0 15px 0; font-size: 18px; text-transform: uppercase; letter-spacing: 1px; color: #00e5ff; }

        .control-group { margin-bottom: 15px; }
        label { display: block; margin-bottom: 8px; font-size: 12px; color: #aaa; }

        /* æŒ‰é’®ç½‘æ ¼ */
        .shape-grid { display: grid; grid-template-columns: repeat(2, 1fr); gap: 8px; }
        button {
            background: rgba(255, 255, 255, 0.1);
            border: none; color: white; padding: 8px; border-radius: 6px;
            cursor: pointer; transition: all 0.3s; font-size: 13px;
        }
        button:hover { background: rgba(255, 255, 255, 0.2); }
        button.active { background: #00e5ff; color: #000; font-weight: bold; }

        /* é¢œè‰²é€‰æ‹©å™¨ */
        input[type="color"] {
            width: 100%; height: 35px; border: none; cursor: pointer;
            background: transparent;
        }

        /* çŠ¶æ€æŒ‡ç¤º */
        #status {
            margin-top: 15px; font-size: 12px; color: #00ff88;
            display: flex; align-items: center; gap: 8px;
        }
        .dot { width: 8px; height: 8px; background: #00ff88; border-radius: 50%; display: inline-block; }
        .dot.inactive { background: #ff4444; }

        /* æ‘„åƒå¤´é¢„è§ˆ (å¯é€‰ï¼Œæ–¹ä¾¿è°ƒè¯•) */
        #camera-preview {
            position: absolute; bottom: 20px; left: 20px;
            width: 160px; height: 120px;
            border-radius: 8px; opacity: 0.7;
            transform: scaleX(-1); /* é•œåƒ */
            pointer-events: none;
            border: 1px solid rgba(255,255,255,0.2);
        }

        @media (max-width: 768px) {
            #ui-panel { width: 220px; top: 64px; right: 12px; padding: 14px; }
            #camera-preview { width: 120px; height: 90px; bottom: 12px; left: 12px; }
        }

        @media (orientation: landscape) {
            #ui-panel { top: 12px; right: 12px; width: 210px; }
        }
    </style>

    <!-- å¼•å…¥ Three.js (æœ¬åœ°) -->
    <script src="js/three.min.js"></script>
    <!-- å¼•å…¥ MediaPipe (æœ¬åœ°) -->
    <script src="js/camera_utils.js"></script>
    <script src="js/control_utils.js"></script>
    <script src="js/hands.js"></script>
    <script>
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', function () {
                navigator.serviceWorker.register('./sw.js');
            });
        }
    </script>
</head>
<body>

    <div id="loader">
        <h1>æ­£åœ¨åˆå§‹åŒ–ç³»ç»Ÿ...</h1>
        <p>è¯·å…è®¸æ‘„åƒå¤´æƒé™ä»¥å¯ç”¨æ‰‹åŠ¿æ§åˆ¶</p>
    </div>

    <div id="toolbar">
        <button id="panel-toggle" class="tool-btn">âœ• é¢æ¿</button>
        <button id="orientation-btn" class="tool-btn">âŸ³ æ—‹è½¬</button>
        <button id="fullscreen-btn" class="tool-btn">â›¶ å…¨å±</button>
    </div>

    <div id="ui-panel">
        <h2>ç²’å­æ§åˆ¶å™¨</h2>
        
        <div class="control-group">
            <label>é€‰æ‹©å½¢æ€ (Shape)</label>
            <div class="shape-grid">
                <button class="shape-btn active" data-shape="heart">â¤ï¸ çˆ±å¿ƒ</button>
                <button class="shape-btn" data-shape="flower">ğŸŒ¹ èŠ±æœµ</button>
                <button class="shape-btn" data-shape="saturn">ğŸª åœŸæ˜Ÿ</button>
                <button class="shape-btn" data-shape="buddha">ğŸ§˜ ä½›åƒ</button>
                <button class="shape-btn" data-shape="fireworks" style="grid-column: span 2;">ğŸ† çƒŸèŠ±æ‰©æ•£</button>
            </div>
        </div>

        <div class="control-group">
            <label>ç²’å­é¢œè‰² (Color)</label>
            <input type="color" id="color-picker" value="#00e5ff">
        </div>

        <div id="status">
            <span class="dot inactive" id="cam-dot"></span>
            <span id="hand-status">ç­‰å¾…æ‘„åƒå¤´...</span>
        </div>
    </div>

    <video id="camera-preview" playsinline></video>

<script>
    /**
     * 1. Three.js åœºæ™¯åˆå§‹åŒ–
     */
    const scene = new THREE.Scene();
    // æ·»åŠ ä¸€ç‚¹é›¾æ•ˆå¢åŠ æ·±åº¦æ„Ÿ
    scene.fog = new THREE.FogExp2(0x050505, 0.02);

    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.z = 30;

    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    document.body.appendChild(renderer.domElement);

    // ç²’å­ç³»ç»Ÿé…ç½®
    const PARTICLE_COUNT = 15000;
    const particlesGeometry = new THREE.BufferGeometry();
    const positions = new Float32Array(PARTICLE_COUNT * 3);
    const targetPositions = new Float32Array(PARTICLE_COUNT * 3); // ç›®æ ‡å½¢çŠ¶ä½ç½®
    
    // åˆå§‹åŒ–ä½ç½® (éšæœºçƒä½“)
    for(let i=0; i<PARTICLE_COUNT * 3; i++) {
        positions[i] = (Math.random() - 0.5) * 50;
        targetPositions[i] = positions[i];
    }

    particlesGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));

    // ç²’å­æè´¨
    const particleMaterial = new THREE.PointsMaterial({
        color: 0x00e5ff,
        size: 0.15,
        transparent: true,
        opacity: 0.8,
        blending: THREE.AdditiveBlending,
        depthWrite: false
    });

    const particleSystem = new THREE.Points(particlesGeometry, particleMaterial);
    scene.add(particleSystem);

    /**
     * 2. å½¢çŠ¶ç”Ÿæˆç®—æ³• (æ•°å­¦ç”Ÿæˆ)
     */
    const shapes = {
        heart: (i) => {
            // å‚æ•°æ–¹ç¨‹ç”Ÿæˆçˆ±å¿ƒ
            const t = Math.random() * Math.PI * 2;
            const y_factor = Math.random(); 
            // å¡«å……å†…éƒ¨
            const r = Math.sqrt(Math.random()) * 10; 
            
            // çˆ±å¿ƒå…¬å¼
            let x = 16 * Math.pow(Math.sin(t), 3);
            let y = 13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t);
            let z = (Math.random() - 0.5) * 4; // åšåº¦

            const scale = 0.5;
            return { x: x * scale * (r/10), y: y * scale * (r/10), z: z };
        },
        saturn: (i) => {
            const scale = 8;
            if (i < PARTICLE_COUNT * 0.3) {
                // æ˜Ÿçƒæœ¬ä½“ (çƒä½“)
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);
                const r = 4 * Math.cbrt(Math.random()); 
                return {
                    x: r * Math.sin(phi) * Math.cos(theta),
                    y: r * Math.sin(phi) * Math.sin(theta),
                    z: r * Math.cos(phi)
                };
            } else {
                // åœŸæ˜Ÿç¯ (åœ†ç›˜)
                const angle = Math.random() * Math.PI * 2;
                const r = 5 + Math.random() * 5; // åŠå¾„ 5 åˆ° 10
                return {
                    x: r * Math.cos(angle),
                    y: (Math.random()-0.5) * 0.5, // æ‰å¹³
                    z: r * Math.sin(angle)
                };
            }
        },
        flower: (i) => {
            // ç«ç‘°æ›²çº¿
            const k = 4; // èŠ±ç“£æ•°
            const theta = Math.random() * Math.PI * 2;
            const r = Math.cos(k * theta) * 10;
            const z_offset = Math.pow(r, 2) / 20; // èŠ±æœµå‡¹é™·æ„Ÿ
            
            // å¢åŠ éšæœºæ•£å¸ƒå¡«å……
            const spread = Math.random();
            return {
                x: r * Math.cos(theta) * spread,
                y: r * Math.sin(theta) * spread,
                z: z_offset - 5
            };
        },
        buddha: (i) => {
            // ç¨‹åºåŒ–è¿‘ä¼¼ï¼šä¸‰ä¸ªçƒä½“å †å  (åº•åº§ã€èº«ä½“ã€å¤´)
            const r1 = Math.random();
            let p = {x:0, y:0, z:0};
            
            if (i < PARTICLE_COUNT * 0.4) {
                // è…¿éƒ¨/åº•åº§ (æ‰æ¤­çƒ)
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.random() * Math.PI;
                const rad = 6 * Math.sqrt(Math.random());
                p.x = rad * Math.cos(theta);
                p.z = rad * Math.sin(theta);
                p.y = (Math.random() * 4) - 8;
            } else if (i < PARTICLE_COUNT * 0.8) {
                // èº«ä½“
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);
                const rad = 4.5 * Math.cbrt(Math.random());
                p.x = rad * Math.sin(phi) * Math.cos(theta);
                p.y = rad * Math.sin(phi) * Math.sin(theta) - 2;
                p.z = rad * Math.cos(phi);
            } else {
                // å¤´éƒ¨
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);
                const rad = 2.5 * Math.cbrt(Math.random());
                p.x = rad * Math.sin(phi) * Math.cos(theta);
                p.y = rad * Math.sin(phi) * Math.sin(theta) + 4;
                p.z = rad * Math.cos(phi);
            }
            return p;
        },
        fireworks: (i) => {
            // éšæœºçƒä½“ï¼Œä½†åœ¨æ¸²æŸ“å¾ªç¯ä¸­ä¼šä¹˜ä»¥å·¨å¤§çš„æ‰©æ•£ç³»æ•°
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.acos(2 * Math.random() - 1);
            const r = 2 + Math.random() * 5; 
            return {
                x: r * Math.sin(phi) * Math.cos(theta),
                y: r * Math.sin(phi) * Math.sin(theta),
                z: r * Math.cos(phi)
            };
        }
    };

    // å˜æ¢å½¢çŠ¶å‡½æ•°
    function morphTo(shapeType) {
        const generator = shapes[shapeType] || shapes.heart;
        
        // å¦‚æœæ˜¯åœŸæ˜Ÿï¼Œç¨å¾®æ—‹è½¬ä¸€ä¸‹æ•´ä½“è®©ç¯å€¾æ–œ
        if(shapeType === 'saturn') {
            particleSystem.rotation.z = 0.4;
            particleSystem.rotation.x = 0.4;
        } else {
            new TWEEN_Simple_Rotate(particleSystem.rotation, {x:0, z:0}, 1000);
        }

        for (let i = 0; i < PARTICLE_COUNT; i++) {
            const pos = generator(i);
            targetPositions[i * 3] = pos.x;
            targetPositions[i * 3 + 1] = pos.y;
            targetPositions[i * 3 + 2] = pos.z;
        }
    }

    // ç®€å•çš„ç¼“åŠ¨å·¥å…· (æ¨¡æ‹Ÿ Tween)
    function TWEEN_Simple_Rotate(current, target, duration) {
        const startX = current.x;
        const startZ = current.z;
        const startTime = Date.now();
        
        function update() {
            const now = Date.now();
            const progress = Math.min((now - startTime) / duration, 1);
            current.x = startX + (target.x - startX) * progress;
            current.z = startZ + (target.z - startZ) * progress;
            if (progress < 1) requestAnimationFrame(update);
        }
        update();
    }

    // åˆå§‹åŒ–ä¸ºçˆ±å¿ƒ
    morphTo('heart');

    /**
     * 3. äº¤äº’é€»è¾‘ (æ‰‹åŠ¿ & UI)
     */
    
    // å…¨å±€å˜é‡
    let handExpansionFactor = 0; // 0 = æ­£å¸¸, 1 = çˆ†ç‚¸/æ”¾å¤§
    let isHandDetected = false;
    let currentShape = 'heart';
    let lastIndexTip = null;
    let cameraYaw = 0;
    let cameraPitch = 0;
    const dragSensitivity = 2.0;
    let resetHoldFrames = 0;
    let resetTriggered = false;

    function resetCameraView() {
        cameraYaw = 0;
        cameraPitch = 0;
        camera.rotation.set(0, 0, 0);
    }

    const panelToggleBtn = document.getElementById('panel-toggle');
    const orientationBtn = document.getElementById('orientation-btn');
    let panelHidden = false;

    function updatePanelToggleText() {
        panelToggleBtn.textContent = panelHidden ? 'â˜° é¢æ¿' : 'âœ• é¢æ¿';
    }

    function setPanelHidden(hidden) {
        panelHidden = hidden;
        document.body.classList.toggle('panel-hidden', hidden);
        updatePanelToggleText();
    }

    function getOrientationLabel() {
        return window.matchMedia('(orientation: portrait)').matches ? 'portrait' : 'landscape';
    }

    function updateOrientationButton() {
        orientationBtn.textContent = getOrientationLabel() === 'portrait' ? 'âŸ³ æ¨ªå±' : 'âŸ³ ç«–å±';
    }

    async function toggleOrientation() {
        const target = getOrientationLabel() === 'portrait' ? 'landscape' : 'portrait';
        if (!document.fullscreenElement && document.documentElement.requestFullscreen) {
            try { await document.documentElement.requestFullscreen(); } catch (e) {}
        }
        if (screen.orientation && screen.orientation.lock) {
            try { await screen.orientation.lock(target); } catch (e) {}
        }
        document.body.classList.toggle('force-landscape', target === 'landscape');
        document.body.classList.toggle('force-portrait', target === 'portrait');
        updateOrientationButton();
    }

    updateOrientationButton();

    panelToggleBtn.addEventListener('click', () => setPanelHidden(!panelHidden));
    orientationBtn.addEventListener('click', () => toggleOrientation());

    // UI äº‹ä»¶ç›‘å¬
    document.querySelectorAll('.shape-btn').forEach(btn => {
        btn.addEventListener('click', (e) => {
            document.querySelectorAll('.shape-btn').forEach(b => b.classList.remove('active'));
            e.target.classList.add('active');
            currentShape = e.target.getAttribute('data-shape');
            morphTo(currentShape);
        });
    });

    document.getElementById('color-picker').addEventListener('input', (e) => {
        particleMaterial.color.set(e.target.value);
    });

    document.getElementById('fullscreen-btn').addEventListener('click', () => {
        if (!document.fullscreenElement) document.documentElement.requestFullscreen();
        else if (document.exitFullscreen) document.exitFullscreen();
    });

    /**
     * 4. MediaPipe Hands Setup
     */
    const videoElement = document.getElementById('camera-preview');
    const handStatus = document.getElementById('hand-status');
    const camDot = document.getElementById('cam-dot');

    function onResults(results) {
        if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
            isHandDetected = true;
            camDot.classList.remove('inactive');
            handStatus.textContent = "æ‰‹åŠ¿å·²æ•æ‰";
            document.getElementById('loader').style.opacity = 0;
            setTimeout(() => document.getElementById('loader').style.display = 'none', 500);

            const landmarks = results.multiHandLandmarks[0];
            
            // è®¡ç®—å¤§æ‹‡æŒ‡æŒ‡å°–(4)å’Œé£ŸæŒ‡æŒ‡å°–(8)çš„è·ç¦»
            const thumbTip = landmarks[4];
            const indexTip = landmarks[8];
            const middleTip = landmarks[12];
            
            // ç®€å•çš„æ¬§å‡ é‡Œå¾—è·ç¦» (zè½´å½±å“è¾ƒå°ï¼Œä¸»è¦çœ‹xyå¹³é¢)
            const distance = Math.sqrt(
                Math.pow(thumbTip.x - indexTip.x, 2) + 
                Math.pow(thumbTip.y - indexTip.y, 2)
            );

            // æ˜ å°„è·ç¦»åˆ°è†¨èƒ€ç³»æ•°
            // è·ç¦»é€šå¸¸åœ¨ 0.02 (é—­åˆ) åˆ° 0.2 (å¼ å¼€) ä¹‹é—´
            // æˆ‘ä»¬å¸Œæœ›ï¼šé—­åˆ -> 0 (æ­£å¸¸/æ”¶ç¼©), å¼ å¼€ -> 1+ (æ”¾å¤§)
            let factor = (distance - 0.05) * 6; 
            if (factor < 0) factor = 0; // æœ€å°ä¸å°äº0
            if (factor > 3) factor = 3; // é™åˆ¶æœ€å¤§å€¼

            // å¹³æ»‘å¤„ç† (Lerp)
            handExpansionFactor += (factor - handExpansionFactor) * 0.1;

            const resetDistance = Math.sqrt(
                Math.pow(thumbTip.x - middleTip.x, 2) +
                Math.pow(thumbTip.y - middleTip.y, 2)
            );

            if (resetDistance < 0.03) {
                resetHoldFrames += 1;
            } else {
                resetHoldFrames = 0;
                resetTriggered = false;
            }

            if (resetHoldFrames > 6 && !resetTriggered) {
                resetTriggered = true;
                resetCameraView();
                lastIndexTip = null;
            }

            if (lastIndexTip && !resetTriggered) {
                const dx = indexTip.x - lastIndexTip.x;
                const dy = indexTip.y - lastIndexTip.y;
                cameraYaw -= dx * dragSensitivity;
                cameraPitch -= dy * dragSensitivity;
                if (cameraPitch > 1.1) cameraPitch = 1.1;
                if (cameraPitch < -1.1) cameraPitch = -1.1;
                camera.rotation.set(cameraPitch, cameraYaw, 0);
            }
            lastIndexTip = { x: indexTip.x, y: indexTip.y };

        } else {
            isHandDetected = false;
            camDot.classList.add('inactive');
            handStatus.textContent = "æœªæ£€æµ‹åˆ°æ‰‹éƒ¨";
            // å¦‚æœæ²¡æ‰‹ï¼Œæ…¢æ…¢å½’é›¶
            handExpansionFactor += (0 - handExpansionFactor) * 0.05;
            lastIndexTip = null;
            resetHoldFrames = 0;
            resetTriggered = false;
        }
    }

    const hands = new Hands({locateFile: (file) => {
        return `js/${file}`;
    }});

    hands.setOptions({
        maxNumHands: 1,
        modelComplexity: 1,
        minDetectionConfidence: 0.5,
        minTrackingConfidence: 0.5
    });

    hands.onResults(onResults);

    const cameraUtils = new Camera(videoElement, {
        onFrame: async () => {
            await hands.send({image: videoElement});
        },
        width: 320,
        height: 240
    });
    
    // å¯åŠ¨æ‘„åƒå¤´
    cameraUtils.start().catch(err => {
        console.error(err);
        handStatus.textContent = "æ‘„åƒå¤´è®¿é—®å¤±è´¥";
        document.querySelector('#loader h1').textContent = "æ— æ³•è®¿é—®æ‘„åƒå¤´";
    });

    /**
     * 5. æ¸²æŸ“å¾ªç¯
     */
    const clock = new THREE.Clock();

    function animate() {
        requestAnimationFrame(animate);
        
        const time = clock.getElapsedTime();
        const positionsAttr = particlesGeometry.attributes.position;
        const currentPosArr = positionsAttr.array;

        // æ ¹æ®æ‰‹åŠ¿è°ƒæ•´çš„åŸºç¡€ç¼©æ”¾
        // å¦‚æœæ˜¯çƒŸèŠ±æ¨¡å¼ï¼ŒåŸºç¡€æ‰©æ•£è¦å¤§å¾—å¤š
        let expansionBase = 1 + handExpansionFactor;
        if (currentShape === 'fireworks') {
            expansionBase = 1 + (handExpansionFactor * 3); // çƒŸèŠ±ç‚¸å¾—æ›´è¿œ
        }

        // æ—‹è½¬åœºæ™¯
        if(currentShape !== 'saturn') {
            particleSystem.rotation.y += 0.002;
        }

        for (let i = 0; i < PARTICLE_COUNT; i++) {
            const idx = i * 3;
            
            // 1. è·å–ç›®æ ‡ä½ç½®
            let tx = targetPositions[idx];
            let ty = targetPositions[idx + 1];
            let tz = targetPositions[idx + 2];

            // 2. åº”ç”¨æ‰‹åŠ¿æ‰©æ•£é€»è¾‘
            // é€»è¾‘ï¼šä½ç½® = ç›®æ ‡ä½ç½® + (æ–¹å‘å‘é‡ * æ‰©æ•£åŠ›åº¦)
            // ç®€å•çš„åšæ³•æ˜¯ç›´æ¥ä¹˜ä»¥ç¼©æ”¾ç³»æ•°ï¼Œæˆ–è€…æ·»åŠ å™ªå£°
            
            // æ·»åŠ ä¸€ç‚¹åŠ¨æ€å™ªå£°è®©ç²’å­æ´»ç€
            const noise = Math.sin(time * 2 + i) * 0.05;

            // æ’å€¼ç§»åŠ¨å½“å‰ç²’å­åˆ°ç›®æ ‡ä½ç½®
            // lerp factor 0.05 æ§åˆ¶å˜å½¢é€Ÿåº¦
            currentPosArr[idx] += (tx * expansionBase - currentPosArr[idx]) * 0.08 + noise;
            currentPosArr[idx + 1] += (ty * expansionBase - currentPosArr[idx + 1]) * 0.08 + noise;
            currentPosArr[idx + 2] += (tz * expansionBase - currentPosArr[idx + 2]) * 0.08 + noise;
        }

        positionsAttr.needsUpdate = true;
        renderer.render(scene, camera);
    }

    // çª—å£å¤§å°è°ƒæ•´
    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
        updateOrientationButton();
    });

    animate();

</script>
</body>
</html>
